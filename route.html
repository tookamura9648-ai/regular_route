<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
<title>順路帳＋地図（カードタップでルート/HUD/次操作自動更新）</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

<style>
  :root { --top-bar-height: 52px; }
  body { margin:0; background:#f2f2f2; font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",sans-serif; overflow:hidden; }

  #top-bar{
    height:var(--top-bar-height); display:flex; align-items:center;
    padding:4px 8px; box-sizing:border-box; background:#333; color:#fff; font-size:13px; gap:8px;
  }
  #top-bar-left{ display:flex; align-items:center; gap:6px; }
  #top-bar-right{ margin-left:auto; }
  #top-bar button,#top-bar label{
    display:inline-block; padding:4px 8px; border-radius:6px; background:#fff; color:#333;
    font-weight:bold; font-size:12px; border:none; cursor:pointer; white-space:nowrap;
  }
  #csvFile{ display:none; }
  #status{ font-size:11px; opacity:.9; }

 /* 横スクロール：カード単位で1枚ずつスナップ */
#container{
  display:flex;
  overflow-x:auto;
  scroll-snap-type:x mandatory;
  scroll-padding-left: 8px;     /* スナップ位置の気持ちよさ */
  gap: 8px;                     /* カード間の隙間 */
  padding: 8px;                 /* 外枠余白 */
  box-sizing:border-box;
  height: calc(100vh - var(--top-bar-height));
  white-space: nowrap;
  -webkit-overflow-scrolling: touch;
}

.card{
  scroll-snap-align: start;
  scroll-snap-stop: always;     /* iOS系で “1枚ずつ”感が増える */
  flex: 0 0 calc((100vw - 8px*2 - 8px*2) / 3); /* ★縦向き: 3枚見せ */
  height: 100%;
  margin: 0;                    /* container側でgap/padding管理 */
}

/* 横向き（広い画面）は 5枚見せ */
@media (orientation: landscape){
  .card{
    flex-basis: calc((100vw - 8px*2 - 8px*4) / 5); /* ★横向き: 5枚見せ */
  }
}

/* 旧groupは使わないので無効化（残っててもOK） */
.group{ display: none; }

  
  .card-top{
  width:100%;
  display:flex;
  flex-direction:column;
  font-size:1.1rem;
  line-height:1.2;
  margin-bottom:4px;
  white-space:pre-line;

  background:rgba(0,0,0,.9);
  color:#fff;
  padding:4px 6px;
  border-radius:6px;

  /* ★追加：高さを揃える */
  height: 110px;          /* 好みで調整（例: 80〜110） */
  box-sizing: border-box;
  overflow: hidden;      /* まず隠す */
}

  .card-no{ font-weight:bold; color:#fff; }
  .card-type{ font-size:.95rem; color:#ddd; }
  .card-note{ font-size:.85rem; color:#ccc; margin-top:2px; line-height:1.1; }

  .card-main{ flex:1; display:flex; justify-content:center; gap:4px; overflow:hidden; }
  .vertical-text{ writing-mode:vertical-rl; text-orientation:mixed; white-space:pre-line; word-break:break-all; }
  .name-text{ font-size:1.8rem; font-weight:bold; }
  .addr-text{ font-size:1.2rem; opacity:.9; text-orientation:upright; }

  #container::-webkit-scrollbar{ height:4px; }
  #container::-webkit-scrollbar-thumb{ background:#999; border-radius:2px; }

  /* 地図オーバーレイ */
  #mapOverlay{ position:fixed; inset:0; background:rgba(0,0,0,.6); display:none; z-index:1000; }
  #mapPanel{
    position:absolute; top:5%; left:5%; width:90%; height:90%;
    background:#fff; border-radius:14px; display:flex; flex-direction:column; overflow:hidden;
  }
  #mapHeader{
    height:44px; display:flex; align-items:center; justify-content:space-between;
    padding:0 8px; box-sizing:border-box; background:#333; color:#fff; font-size:13px; gap:6px;
  }
  #mapTitle{ flex:1; padding-right:8px; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }

  /* HUD操作ボタン */
  .hudBtn{
    border:none; background:#fff; color:#333; border-radius:999px; padding:4px 10px;
    font-weight:900; cursor:pointer; white-space:nowrap;
  }
  #mapClose{ border:none; background:#fff; color:#333; border-radius:999px; padding:4px 10px; font-weight:bold; cursor:pointer; }

  /* HUD帯 */
  #hudBanner{
    display:none;
    padding:12px 14px;
    font-size:22px;
    font-weight:900;
    background:#111;
    color:#fff;
    line-height:1.15;
    letter-spacing:.5px;
    border-bottom:2px solid #000;
  }
  #hudBanner.warn{ background:#b00020; }
  #hudSub{
    margin-top:4px;
    font-size:12px;
    opacity:.9;
    font-weight:700;
  }

  #map{ flex:1; }

  /* ========= Splash overlay（初回だけ） ========= */
  #splash{
    position: fixed;
    inset: 0;
    z-index: 2000;
    display: none;
    align-items: center;
    justify-content: center;
    background: radial-gradient(ellipse at center, rgba(0,0,0,.65), rgba(0,0,0,.9));
    color: #fff;
    padding: 18px;
    box-sizing: border-box;
  }
  #splash.show{ display:flex; }

  .splash-card{
    width: min(520px, 92vw);
    border-radius: 18px;
    padding: 18px 16px;
    background: rgba(255,255,255,.06);
    border: 1px solid rgba(255,255,255,.18);
    box-shadow: 0 10px 30px rgba(0,0,0,.35);
    backdrop-filter: blur(8px);
  }
  .splash-title{ font-size: 28px; font-weight: 900; letter-spacing: .5px; }
  .splash-sub{ margin-top: 4px; font-size: 13px; opacity: .9; }

  .splash-loader{
    display:flex;
    gap:10px;
    margin: 16px 0 10px;
    align-items:center;
  }
  .splash-loader .dot{
    width: 10px; height: 10px; border-radius: 999px;
    background: rgba(255,255,255,.85);
    animation: splashBounce 1.1s infinite ease-in-out;
  }
  .splash-loader .dot:nth-child(2){ animation-delay: .15s; }
  .splash-loader .dot:nth-child(3){ animation-delay: .3s; }
  @keyframes splashBounce{
    0%,80%,100%{ transform: translateY(0); opacity:.65; }
    40%{ transform: translateY(-8px); opacity:1; }
  }

  .splash-gps{ font-size: 15px; font-weight: 800; opacity: .95; }
  .splash-gps.ok{ color: #b7ffcc; }
  .splash-gps.slow{ opacity: .85; }
  .splash-gps.hint{ opacity: .85; font-weight: 700; }

  .splash-note{
    margin-top: 10px;
    font-size: 12px;
    line-height: 1.4;
    opacity: .9;
  }
  .splash-actions{
    margin-top: 14px;
    display:flex;
    gap:10px;
    justify-content: flex-end;
  }
  .splash-actions button{
    border: none;
    border-radius: 999px;
    padding: 8px 12px;
    font-weight: 900;
    cursor: pointer;
  }
  #splashSkip{ background:#fff; color:#222; opacity:.9; }
  #splashRetry{ background:#111; color:#fff; border:1px solid rgba(255,255,255,.25); }
</style>
</head>
<body>

<!-- Splash（初回だけ） -->
<div id="splash" aria-hidden="true">
  <div class="splash-card">
    <div class="splash-title">regular_route</div>
    <div class="splash-sub">配達ナビ（バイク）</div>

    <div class="splash-loader">
      <div class="dot"></div><div class="dot"></div><div class="dot"></div>
    </div>

    <div id="splashGpsText" class="splash-gps">GPS準備中…</div>

    <div class="splash-note">
      初回だけ位置情報の許可が表示されます。<br>
      許可すると、地図を開いたときにすぐ現在地が出ます。
    </div>

    <div class="splash-actions">
      <button id="splashSkip" type="button">スキップ</button>
      <button id="splashRetry" type="button">再試行</button>
    </div>
  </div>
</div>

<div id="top-bar">
  <div id="top-bar-left">
    <button id="reloadGitHub">GitHub再読込</button>
    <label for="csvFile">ローカルCSV</label>
    <input id="csvFile" type="file" accept=".csv">
  </div>
  <div id="top-bar-right">
    <div id="status">GitHubのCSVから自動読み込み（横向き推奨／カードタップでナビ）</div>
  </div>
</div>

<div id="container"></div>

<div id="mapOverlay">
  <div id="mapPanel">
    <div id="mapHeader">
      <div id="mapTitle">地図</div>
      <button id="hudToggle" class="hudBtn">HUD ON</button>
      <button id="prevTurn" class="hudBtn">◀ 前</button>
      <button id="nextTurn" class="hudBtn">次 ▶</button>
      <button id="mapClose">閉じる</button>
    </div>

    <div id="hudBanner">
      <div id="hudMain">（次の操作）</div>
      <div id="hudSub"></div>
    </div>

    <div id="map"></div>
  </div>
</div>

<script>
// ====== GitHub上のCSV URL ======
const GITHUB_CSV_URL =
  "https://raw.githubusercontent.com/tookamura9648-ai/regular_route/main/regular_route/住所録2025.csv";

// { no, type, name, addr1, addr2, addr3, lat, lng, area, note }
let entries = [];

const fileInput = document.getElementById("csvFile");
const statusEl  = document.getElementById("status");
const container = document.getElementById("container");
const reloadBtn = document.getElementById("reloadGitHub");

// 地図関連
let map;
let destMarker;
let userMarker;
let geoWatchId = null;
let routeFromHereLayer = null;
let userLat = null;
let userLng = null;

// HUD/UI
const mapOverlay = document.getElementById("mapOverlay");
const mapTitle   = document.getElementById("mapTitle");
const mapClose   = document.getElementById("mapClose");
const hudToggle  = document.getElementById("hudToggle");
const prevTurnBtn= document.getElementById("prevTurn");
const nextTurnBtn= document.getElementById("nextTurn");
const hudBanner  = document.getElementById("hudBanner");
const hudMainEl  = document.getElementById("hudMain");
const hudSubEl   = document.getElementById("hudSub");

let hudOn = true;

// 次操作管理（“自動更新”の核）
let maneuverList = [];
let activeIdx = 0;
let state = "idle";        // "idle" | "approaching" | "arrived"
let lastDist = null;
let lastVibeIdx = -1;

// 次操作地点マーカー（任意）
let nextMarker = null;

// ====== Splash制御（初回だけ） ======
const splash = document.getElementById("splash");
const splashGpsText = document.getElementById("splashGpsText");
const splashSkip = document.getElementById("splashSkip");
const splashRetry = document.getElementById("splashRetry");

const SPLASH_KEY = "regular_route_seen_splash_v1";
function isFirstRun(){ return localStorage.getItem(SPLASH_KEY) !== "1"; }
function markSeen(){ localStorage.setItem(SPLASH_KEY, "1"); }

function showSplash(){
  splash.classList.add("show");
  splash.setAttribute("aria-hidden","false");
}
function hideSplash(){
  splash.classList.remove("show");
  splash.setAttribute("aria-hidden","true");
}

splashSkip.addEventListener("click", ()=>{
  markSeen();
  hideSplash();
});

splashRetry.addEventListener("click", ()=>{
  if (splashGpsText){
    splashGpsText.textContent = "GPS準備中…";
    splashGpsText.className = "splash-gps";
  }
  startGeoWarmup({ silent:true, allowRestart:true });
});

// ====== 新聞種フィルタ ======
function hasEvening(typeStr){ return /よセ|日経セ|日経代/.test(typeStr || ""); }
function matchTypeFilter(typeVal, entryType){
  if (!typeVal) return true;
  const evening = hasEvening(entryType);
  if (typeVal === "evening") return evening;
  if (typeVal === "morning") return !evening;
  return true;
}
function filterByUrlParams(list){
  const params = new URLSearchParams(location.search);
  const areaParam = params.get("area") || "";
  const typeParam = params.get("type") || "";
  return list.filter(e => {
    if (areaParam && e.area !== areaParam) return false;
    if (!matchTypeFilter(typeParam, e.type || "")) return false;
    return true;
  });
}

// ====== GitHub/ローカルCSV ======
async function loadCsvFromGitHub(){
  statusEl.textContent = "GitHub からCSVを読み込み中…";
  try{
    const res = await fetch(GITHUB_CSV_URL, { cache:"no-cache" });
    if (!res.ok) throw new Error("HTTP " + res.status);
    const text = await res.text();
    const parsed = parseCsvToEntries(text);
    entries = parsed;
    statusEl.textContent = `GitHub から読み込み完了（${entries.length}件）`;
    renderCards();
  }catch(e){
    console.error(e);
    statusEl.textContent = "GitHub CSV 読み込み失敗。ローカルCSVを使ってください。";
    renderCards();
  }
}
reloadBtn.addEventListener("click", loadCsvFromGitHub);

fileInput.addEventListener("change",(e)=>{
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev)=>{
    const text = ev.target.result;
    const parsed = parseCsvToEntries(text);
    if (parsed.length === 0) { alert("有効なデータがありません。CSVを確認してください。"); return; }
    entries = parsed;
    statusEl.textContent = `ローカルCSVを読み込みました（${entries.length}件）`;
    renderCards();
  };
  reader.readAsText(file, "Shift_JIS");
});

function parseCSV(text){
  const rows=[]; let row=[]; let field=""; let inQuotes=false;
  for(let i=0;i<text.length;i++){
    const c=text[i];
    if(c === '"'){
      if(inQuotes && text[i+1] === '"'){ field+='"'; i++; }
      else inQuotes = !inQuotes;
    }else if(c === "," && !inQuotes){
      row.push(field); field="";
    }else if((c === "\n" || c === "\r") && !inQuotes){
      if(c === "\r" && text[i+1] === "\n") i++;
      row.push(field); rows.push(row);
      row=[]; field="";
    }else{
      field += c;
    }
  }
  if(field.length>0 || row.length>0){ row.push(field); rows.push(row); }
  return rows;
}

function parseCsvToEntries(csvText){
  const rows=parseCSV(csvText); const result=[];
  rows.forEach((colsRaw, idx)=>{
    const cols = colsRaw.map(c => (c||"").trim());
    if(cols.every(c=>c==="")) return;
    const joined = cols.join("");
    if(idx===0 && /購読|番号|新聞|種類|名前|氏名|地名|番地|建物|住所|緯度|経度|区域|備考|area|note/i.test(joined)) return;

    const no=cols[0]||"", type=cols[1]||"", name=cols[2]||"";
    const addr1=cols[3]||"", addr2=cols[4]||"", addr3=cols[5]||"";
    if(!no && !name) return;

    let lat=null,lng=null;
    if(cols.length>=8){
      const latNum=Number((cols[6]||"").replace(/,/g,""));
      const lngNum=Number((cols[7]||"").replace(/,/g,""));
      if(!Number.isNaN(latNum) && !Number.isNaN(lngNum)){ lat=latNum; lng=lngNum; }
    }
    const area=cols[8]||"", note=cols[9]||"";
    result.push({ no,type,name,addr1,addr2,addr3,lat,lng,area,note });
  });
  return result;
}

function chunk(array,size){
  const out=[];
  for(let i=0;i<array.length;i+=size) out.push(array.slice(i,i+size));
  return out;
}

function renderCards() {
  container.innerHTML = "";

  const viewEntries = filterByUrlParams(entries);

  viewEntries.forEach(item => {
    const card = document.createElement("div");
    card.className = "card";

    card.dataset.no = item.no || "";
    card.dataset.type = item.type || "";
    card.dataset.name = item.name || "";
    card.dataset.addr1 = item.addr1 || "";
    card.dataset.addr2 = item.addr2 || "";
    card.dataset.addr3 = item.addr3 || "";
    if (item.lat != null && item.lng != null) {
      card.dataset.lat = item.lat;
      card.dataset.lng = item.lng;
    }
    card.dataset.area = item.area || "";
    card.dataset.note = item.note || "";

    const top = document.createElement("div");
    top.className = "card-top";

    const noEl = document.createElement("div");
    noEl.className = "card-no";
    noEl.textContent = item.no || "";

    const typeEl = document.createElement("div");
    typeEl.className = "card-type";
    typeEl.textContent = item.type || "";

    top.appendChild(noEl);
    top.appendChild(typeEl);

    if (item.note) {
      const noteEl = document.createElement("div");
      noteEl.className = "card-note";
      noteEl.textContent = item.note;
      top.appendChild(noteEl);
    }

    const main = document.createElement("div");
    main.className = "card-main";

    const nameEl = document.createElement("div");
    nameEl.className = "vertical-text name-text";
    nameEl.textContent = item.name || "";

    const addr1El = document.createElement("div");
    addr1El.className = "vertical-text addr-text";
    addr1El.textContent = item.addr1 || "";

    const addr2El = document.createElement("div");
    addr2El.className = "vertical-text addr-text";
    addr2El.textContent = item.addr2 || "";

    const addr3El = document.createElement("div");
    addr3El.className = "vertical-text addr-text";
    addr3El.textContent = item.addr3 || "";

    main.appendChild(nameEl);
    if (item.addr3) main.appendChild(addr3El);
    if (item.addr2) main.appendChild(addr2El);
    if (item.addr1) main.appendChild(addr1El);

    card.appendChild(top);
    card.appendChild(main);

    card.addEventListener("click", onCardClick);

    container.appendChild(card);
  });
}


// ====== 地図起動 ======
mapClose.addEventListener("click", ()=>{ mapOverlay.style.display="none"; });

hudToggle.addEventListener("click", ()=>{
  hudOn = !hudOn;
  hudToggle.textContent = hudOn ? "HUD ON" : "HUD OFF";
  if(!hudOn){ hudBanner.style.display="none"; hudBanner.classList.remove("warn"); }
  else { hudBanner.style.display="block"; }
});

prevTurnBtn.addEventListener("click", ()=>{
  if(maneuverList.length === 0) return;
  activeIdx = Math.max(0, activeIdx - 1);
  resetAutoState();
  renderHudOnce();
});

nextTurnBtn.addEventListener("click", ()=>{
  if(maneuverList.length === 0) return;
  activeIdx = Math.min(maneuverList.length - 1, activeIdx + 1);
  resetAutoState();
  renderHudOnce();
});

function onCardClick(e){
  const card = e.currentTarget;
  const no = card.dataset.no || "";
  const name = card.dataset.name || "";
  const addr = [card.dataset.addr1, card.dataset.addr2, card.dataset.addr3].filter(Boolean).join(" ");
  const label = (`${no} ${name}`.trim() || addr || "地図").slice(0,40);

  const lat = card.dataset.lat ? Number(card.dataset.lat) : null;
  const lng = card.dataset.lng ? Number(card.dataset.lng) : null;
  if(lat==null || lng==null || Number.isNaN(lat) || Number.isNaN(lng)){
    alert("この順路には緯度・経度がありません。CSVに緯度/経度を入れてください。");
    return;
  }
  openMapAndRoute(label, lat, lng);
}

function openMapAndRoute(label, lat, lng){
  mapTitle.textContent = label;
  mapOverlay.style.display="block";

  if(!map) initMap(lat,lng);
  else map.setView([lat,lng], 17);

  if(!destMarker) destMarker = L.marker([lat,lng]).addTo(map);
  else destMarker.setLatLng([lat,lng]);

  if(routeFromHereLayer){ map.removeLayer(routeFromHereLayer); routeFromHereLayer=null; }
  if(nextMarker){ map.removeLayer(nextMarker); nextMarker=null; }

  // 状態初期化
  maneuverList = [];
  activeIdx = 0;
  resetAutoState();
  hudBanner.style.display = hudOn ? "block" : "none";
  hudMainEl.textContent = "ルート取得中…";
  hudSubEl.textContent = "";

  setTimeout(()=> map.invalidateSize(), 200);
  routeFromHereTo({ lat, lng });
}

function initMap(lat,lng){
  map = L.map("map");
  L.tileLayer("https://cyberjapandata.gsi.go.jp/xyz/std/{z}/{x}/{y}.png",{
    attribution:"地理院タイル", maxZoom:18, minZoom:5
  }).addTo(map);
  map.setView([lat,lng],17);
  startGeoWatch(); // 地図表示時にも確実に開始
}

// ====== 位置情報 warmup（起動時点で開始／Splashと連動） ======
function startGeoWarmup(opts = {}){
  const { silent = true, allowRestart = false } = opts;

  if (!navigator.geolocation){
    console.warn("Geolocation がサポートされていません。");
    if (isFirstRun() && splashGpsText){
      splashGpsText.textContent = "この端末は位置情報に対応していません";
      splashGpsText.className = "splash-gps hint";
    }
    return;
  }

  // 既に走っているなら通常は何もしない（再試行時だけ例外）
  if (geoWatchId != null && !allowRestart) return;

  // 再試行で再開したい場合：一度止めて再スタート
  if (geoWatchId != null && allowRestart){
    navigator.geolocation.clearWatch(geoWatchId);
    geoWatchId = null;
  }

  // Splash上の文言を“静かに”更新
  if (isFirstRun() && splashGpsText){
    splashGpsText.textContent = "GPS準備中…";
    splashGpsText.className = "splash-gps";
  }

  // ① 初回1発で初速UP（失敗してもアラートは出さない）
  navigator.geolocation.getCurrentPosition(
    pos => {
      userLat = pos.coords.latitude;
      userLng = pos.coords.longitude;
      updateUserMarkerIfMapReady();
      tickAutoManeuver?.();

      if (isFirstRun() && splashGpsText){
        splashGpsText.textContent = "GPS準備完了 ✓";
        splashGpsText.className = "splash-gps ok";
      }
    },
    err => {
      console.warn("getCurrentPosition 失敗:", err);
      if (isFirstRun() && splashGpsText){
        splashGpsText.textContent = "GPS準備中…（許可が必要な場合があります）";
        splashGpsText.className = "splash-gps hint";
      }
      if (!silent){
        // 方針：ここではエラー表示しない（初回ストレスを避ける）
      }
    },
    { enableHighAccuracy:true, maximumAge:0, timeout:12000 }
  );

  // ② 継続追跡
  geoWatchId = navigator.geolocation.watchPosition(
    pos => {
      userLat = pos.coords.latitude;
      userLng = pos.coords.longitude;
      updateUserMarkerIfMapReady();
      tickAutoManeuver?.();

      // 初回だけ：fixが来たら少し待ってSplashを閉じる
      if (isFirstRun() && splash && splash.classList.contains("show")){
        if (splashGpsText){
          splashGpsText.textContent = "GPS準備完了 ✓";
          splashGpsText.className = "splash-gps ok";
        }
        setTimeout(()=>{
          markSeen();
          hideSplash();
        }, 450);
      }
    },
    err => {
      console.warn("watchPosition 失敗:", err);
      if (isFirstRun() && splashGpsText){
        splashGpsText.textContent = "GPS準備中…（屋内だと時間がかかります）";
        splashGpsText.className = "splash-gps slow";
      }
      if (!silent){
        // ここもアラートしない
      }
    },
    { enableHighAccuracy:true, maximumAge:1000, timeout:20000 }
  );

  // 遅い端末向けに表示を少し変える
  if (isFirstRun() && splashGpsText){
    setTimeout(()=>{
      if (userLat == null || userLng == null && splash.classList.contains("show")){
        splashGpsText.textContent = "GPS準備中…（もう少し待ってください）";
        splashGpsText.className = "splash-gps slow";
      }
    }, 4000);
  }
}

// 地図が作られている時だけ現在地マーカー更新
function updateUserMarkerIfMapReady(){
  if (!map || userLat == null || userLng == null) return;
  const latlng = [userLat, userLng];
  if (!userMarker) userMarker = L.circleMarker(latlng, { radius:8 }).addTo(map);
  else userMarker.setLatLng(latlng);
}

// 互換：地図側から呼ばれても warmup を確実に開始
function startGeoWatch(){
  startGeoWarmup({ silent:true });
}

// ====== ルート取得（OSRM steps=true / バイク） ======
async function routeWithSteps(A,B){
  const profiles = ["bike","bicycle","cycling"];
  let lastErr="unknown";

  for(const profile of profiles){
    const url =
      `https://router.project-osrm.org/route/v1/${profile}/` +
      `${A.lng},${A.lat};${B.lng},${B.lat}` +
      `?overview=full&geometries=geojson&alternatives=false&steps=true`;
    try{
      const res = await fetch(url);
      const json = await res.json();
      if(json.code==="Ok"){
        const route=json.routes[0];
        const steps=route.legs?.[0]?.steps ?? [];
        return { profile, geometry: route.geometry.coordinates, steps, route };
      }
      lastErr = json.code || "OSRM error";
    }catch(e){
      lastErr = e.message;
    }
  }
  throw new Error(`ルート取得失敗: ${lastErr}`);
}

// 曲がり角だけ抽出
function buildManeuverList(steps){
  const interesting = new Set([
    "turn","fork",
    "roundabout","rotary",
    "exit roundabout","exit rotary"
  ]);
  const list = [];
  for(const s of steps){
    const t = s?.maneuver?.type;
    if(interesting.has(t)) list.push(s);
  }
  return list;
}

function formatManeuver(step){
  const t = step.maneuver.type;
  const m = step.maneuver.modifier || "";

  if(t==="roundabout" || t==="rotary" || t==="exit roundabout" || t==="exit rotary"){
    return "⟳ ラウンドアバウト";
  }
  if(t==="turn" || t==="fork"){
    if(m.includes("slight right")) return "↗ ゆるく右";
    if(m.includes("slight left"))  return "↖ ゆるく左";
    if(m.includes("right")) return "➡ 右折";
    if(m.includes("left"))  return "⬅ 左折";
    if(m.includes("straight")) return "⬆ 直進";
    return "↩ 進行方向変更";
  }
  return "次の操作";
}

// 距離計算（m）
function haversineMeters(a,b){
  const R=6371000;
  const toRad=(d)=>d*Math.PI/180;
  const dLat=toRad(b.lat-a.lat);
  const dLng=toRad(b.lng-a.lng);
  const lat1=toRad(a.lat), lat2=toRad(b.lat);
  const x = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLng/2)**2;
  return 2*R*Math.asin(Math.min(1,Math.sqrt(x)));
}

function resetAutoState(){
  state="idle";
  lastDist=null;
}

// HUDを1回描画
function renderHudOnce(){
  if(!hudOn) return;
  if(maneuverList.length===0){
    hudBanner.style.display="block";
    hudMainEl.textContent="（曲がり角なし）";
    hudSubEl.textContent="";
    return;
  }
  const step = maneuverList[activeIdx];
  const label = formatManeuver(step);
  const [lon,lat] = step.maneuver.location;
  hudMainEl.textContent = label + "（距離計算中）";
  hudSubEl.textContent = `操作 ${activeIdx+1}/${maneuverList.length}`;
  if(map){
    if(!nextMarker) nextMarker = L.marker([lat,lon]).addTo(map);
    else nextMarker.setLatLng([lat,lon]);
  }
}

// 自動更新：通過で次へ
function tickAutoManeuver(){
  if(!hudOn) return;
  if(userLat==null || userLng==null) return;
  if(maneuverList.length===0) return;
  if(activeIdx >= maneuverList.length) return;

  const SHOW_AT   = 150;
  const ARRIVE_AT = 25;
  const LEAVE_AT  = 45;
  const WARN_AT   = 40;
  const VIBE_AT   = 18;

  const user = { lat:userLat, lng:userLng };
  const step = maneuverList[activeIdx];
  const [lon, lat] = step.maneuver.location;
  const dist = Math.round(haversineMeters(user, { lat, lng:lon }));

  if(dist > SHOW_AT){
    hudBanner.style.display="none";
    hudBanner.classList.remove("warn");
    lastDist = dist;
    return;
  }

  hudBanner.style.display="block";
  const label = formatManeuver(step);
  hudMainEl.textContent = `${label}（${dist}m）`;
  hudSubEl.textContent = `操作 ${activeIdx+1}/${maneuverList.length}`;

  if(dist <= WARN_AT) hudBanner.classList.add("warn");
  else hudBanner.classList.remove("warn");

  if(map){
    if(!nextMarker) nextMarker = L.marker([lat,lon]).addTo(map);
    else nextMarker.setLatLng([lat,lon]);
  }

  if(dist <= VIBE_AT && navigator.vibrate && lastVibeIdx !== activeIdx){
    navigator.vibrate([60,60,60]);
    lastVibeIdx = activeIdx;
  }

  if(state === "idle") state = "approaching";
  if(state === "approaching" && dist <= ARRIVE_AT) state = "arrived";

  if(state === "arrived" && dist >= LEAVE_AT){
    if(activeIdx < maneuverList.length - 1){
      activeIdx++;
      resetAutoState();
      renderHudOnce();
      return;
    }else{
      hudMainEl.textContent = "✅ 目的地付近（最後の操作を通過）";
      hudSubEl.textContent = "";
    }
  }

  lastDist = dist;
}

// ルート描画＋steps反映
async function routeFromHereTo(target){
  // “初回ストレス低減”：ここではalertを減らし、HUDに出す（必要なら）
  if(userLat==null || userLng==null){
    hudBanner.style.display = hudOn ? "block" : "none";
    hudMainEl.textContent = "GPS準備中…（少し待って再タップ）";
    hudSubEl.textContent = "";
    return;
  }
  const A = { lat:userLat, lng:userLng };
  const B = target;

  try{
    const { geometry, steps } = await routeWithSteps(A,B);

    maneuverList = buildManeuverList(steps);
    activeIdx = 0;
    resetAutoState();
    lastVibeIdx = -1;

    const latlngs = geometry.map(([lon,lat]) => [lat,lon]);
    if(routeFromHereLayer) map.removeLayer(routeFromHereLayer);
    routeFromHereLayer = L.polyline(latlngs, { weight:2, opacity:.9 }).addTo(map);
    map.fitBounds(routeFromHereLayer.getBounds(), { padding:[30,30] });

    if(maneuverList.length===0){
      hudBanner.style.display = hudOn ? "block" : "none";
      hudMainEl.textContent = "（曲がり角なし）そのまま進行";
      hudSubEl.textContent = "";
    }else{
      renderHudOnce();
      tickAutoManeuver();
    }
  }catch(err){
    alert("ルート取得に失敗しました：" + err.message);
    console.error(err);
  }
}

// ====== 起動処理 ======
window.addEventListener("load", ()=>{
  renderCards();
  loadCsvFromGitHub();

  // 初回だけSplash → GPS warmup
  if (isFirstRun()){
    showSplash();
    startGeoWarmup({ silent:true });
  } else {
    // 2回目以降も早取りは継続（Splashなし）
    startGeoWarmup({ silent:true });
  }
});
</script>
</body>
</html>



